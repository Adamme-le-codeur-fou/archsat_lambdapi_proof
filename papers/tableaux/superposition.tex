% $Id$

\section{Equational Reasoning with Rigid Unit Superposition}

\EnableBpAbbreviations{}

\newcommand\clauseWithSubst[2]{\ensuremath{#1 ~|~ #2}}
\newcommand\renameVarsSymb{\ensuremath{\textsf{rename}}}
\newcommand\renameVars[1]{\ensuremath{\renameVarsSymb}(#1)}
\newcommand\mapVar[2]{\ensuremath{#2/#1}}

There are many ways of integrating equational reasoning in
Tableaux methods~\cite{brand1975proving,letz2002integration,backeman2015theorem,degtyarev1996you}.
Because our prover does not rely on clausal forms, but on arbitrary formulas
with quantifiers occurring deep inside branches,
we deal with {\em rigid} variables --- variables that can be instantiated
only once.
The problem we want to solve, {\em rigid E-unification}, is the following.
Assume a set of equations $E$, containing rigid variables,
and a {\em target equation} $e = s \approx t$.
We want a substitution $\sigma$ such that
$\bigwedge_{e \in E} e\sigma \vdash_\approx s\sigma \approx t\sigma$;
such a substitution is a {\em solution} to the rigid E-unification problem.

We propose here an approach based on superposition with rigid variables,
as in previous work by Degtyarev and Voronkov~\cite{degtyarev1996you}
and earlier work on rigid paramodulation~\cite{plaisted1995special},
but with significant differences.
First, to avoid constraint solving, we do not use
basic superposition nor constraints.
Second, we introduce a {\em merging} rule that factors together
intermediate (dis)equations that are alpha-equivalent:
with multiple instances of some of the quantified formulas ({\em amplification}),
it becomes important not to duplicate work.
In this aspect, our calculus is quite close to Labelled
Unit Superposition~\cite{iprover_eq_labelled_unit_sup} when using sets as labels.
Third, unlike rigid paramodulation we use a term ordering to orient the
equations.

\subsection{Preliminary Definitions}
%{{{


We write $ \clauseWithSubst{ s \approx t }{ \Sigma}$
(resp. $ \clauseWithSubst{ s \not\approx t }{ \Sigma}$),
the unit clause that contains exactly one equation (resp.~disequation)
under hypothesis $\Sigma$ (which is a set of substitutions).
We write $\clauseWithSubst{\emptyset}{\Sigma}$ for the empty clause under hypothesis $\Sigma$.
We define $\renameVars{e}$, where $e$ is a (dis)equation, as follows:
let $\sigma$ map every (rigid) variable of $e$ to a fresh rigid variable;
then $\renameVars{e} = \clauseWithSubst{ e\sigma }{ \{ \sigma \} }$.
For example, $\renameVars{p(X)\approx a}$
is $\clauseWithSubst{ p(Y)\approx a}{ \{ X\mapsto Y\} }$. % TODO: another example
\todo{explain the purpose of this transformation further?}
The E-unification problem $E \vdash s\approx t$ can be solved by
proving $\clauseWithSubst{\emptyset }{ \Sigma}$
from $\{ \renameVars{e} \}_{ e \in E }
\cup
\{ \renameVars{ s \not\approx t } \}$,
where $\Sigma$ contains the solutions.
The meaning of $s \approx t | \Sigma$ is that for every $\sigma \in \Sigma$,
$s\sigma \approx t\sigma$ is provable.

The point of keeping a set of substitutions, rather than unit clauses paired with
individual substitutions, in order to avoid duplicating the work
for alpha-equivalent clauses.
Indeed, because of amplification, many instances of a given (dis)equation
might be present in a branch of the tableau;
it would be inefficient to repeat the same inference steps with each variant
of the axioms.
Because we apply $\renameVars{e}$ on every initial $e$, clauses do not
share any variable, except in their attached sets of substitutions.

To perform an inference step between two unit (dis)equations, we merge their
sets of substitutions.
Merging $\Sigma$ and $\Sigma'$, intuitively, means
computing $\{ \textsf{merge}(\sigma,\sigma') ~|~ \sigma \in \Sigma, \sigma'\in \Sigma' \}$
for every pair $(\sigma,\sigma')$ of {\em compatible} substitutions.
For example, the resolution step between $p(x,x)| \{ X \mapsto a \}$
and $\lnot p(y,b)| \{ X \mapsto y \}$ is not possible, because the result
would need to map $X$ to $a$ and to $b$  --- impossible because $X$ is rigid.
Compatibility relies on a partial ordering $\leq$,
such that $\sigma \leq \sigma'$ means that $\sigma$ is
less general than $\sigma'$.

Considering a substitution as a function from variables to terms, we can define
the domain of a substitution $\sigma$ as the set of variables which have a non-trivial
binding in $\sigma$.\footnote{a trivial binding maps a variable to itself.}
The co-domain of a substitution is the set of variables occurring in terms in the image of
the domain of the substitution.
In all the following, we will consider idempotent substitutions, i.e.~substitution for which
the domain and co-domain have an empty intersection.

The {\em composition} of substitutions $\sigma \circ \sigma'$
is well-defined iff the domains of $\sigma$ and $\sigma'$ have no
intersection.
In this case,
$\sigma \circ \sigma' \triangleq \left\{ x \mapsto (x\sigma)\sigma' | x \in \text{domain}(\sigma) \right\}$
This definition naturally extends to sets of substitutions:
$\Sigma \circ \sigma' \triangleq \left\{ \sigma \circ \sigma' | \sigma \in \Sigma \right\}$
We then say that $\sigma \leq \sigma'$ iff $\exists \sigma''.~ \sigma \circ \sigma'' = \sigma'$.
We extend that notion to set of substitutions:
$\smash{ \Sigma \leq \Sigma' }$
iff $\smash{ \forall \sigma' \in \Sigma'.~ \exists \sigma \in \Sigma. \sigma \leq \sigma' }$.
The {\em merging} of two substitutions $\sigma \uparrow \sigma'$ as the supremum of $\{\sigma,\sigma'\}$
for the order $\leq$, if it exists, or $\bot$ otherwise.
The merging of sets of substitutions is
$\Sigma \uparrow \Sigma' \triangleq
  \left\{ \sigma \uparrow \sigma' ~|~
    \sigma \in \Sigma, \sigma' \in \Sigma' \right.,
  \sigma \uparrow \sigma' \not= \bot
  \}$.
An inference rule only succeeds if the merging of the premises' substitution
sets is non-empty.

%}}}

\subsection{Inference System}
%{{{

In Figure~\ref{fig:unit-sup-rules}, we present the  rules for unit superposition
with rigid variables.
We adapt notations and names from Schulz's paper on E~\cite{e_brainiac_prover}.
A single bar denotes an inference --- we add the result to the saturation set ---
whereas a double bar is a simplification in which the premises are
replaced by the conclusion(s).
The relation $\prec$ is a {\em reduction ordering}, used to orient equations,
thus pruning the search space.
Typically, $\prec$ is one of RPO or KBO.

\begin{description}
%{{{
  \item[ER] is {\em equality resolution},
    where a disequation $\clauseWithSubst{s \not\approx t}\Sigma$
    is solved by syntactically unifying $s$ and $t$ with $\sigma$,
    if $\sigma$ is compatible with $\Sigma$.
  \item[SN] is superposition into negative literals. A subterm of $u$
    is rewritten using $s \approx t$ after unifying it with $s$
    by $\sigma$.
    The rewriting is done only if $s\sigma \not\preceq t\sigma$,
    a sufficient (but not necessary) condition for a
    ground instance of $s\sigma \approx t\sigma$
    to be oriented left-to-right.
  \item[SP] is similar to SN, but superposes into a positive literal.
  \item[TD1] deletes trivial equations that will never contribute to a proof.
  \item[TD2] deletes clauses with an empty set of substitutions.
    In practice, we only apply a rule if the conclusion is labelled with a
    non-empty set of substitutions.
  \item[ME] merges two alpha-equivalent clauses into a single clause,
    by merging the sets of substitutions.
    This rule is very important in practice, to prevent the search space
    from exploding due to the duplicates of most formulas.
    Superposition deals with this explosion by removing duplicates using
    {\em subsumption}, but in our context subsumption is not complete
    because rigid variables are only proxy for ground terms:
    even if $C\sigma \subseteq D$, the one ground instance of $C$ might not
    be compatible with the ground instance of $D$.
  \item[ES] is a restricted form of equality subsumption. The active
    equation $\clauseWithSubst{ s\approx t}\Sigma $ can be used to delete another clause, as
    in E~\cite{e_brainiac_prover}.
    However, ES only works if $s$ and $t$ are syntactically equal to the
    corresponding subterms in the subsumed clause $C$; otherwise, there is no
    guarantee that further instantiations will not make
    $s\approx t$ incompatible with $C$.
    Moreover, $C$ needs not be entirely removed; only its substitutions
    that are compatible with $\Sigma$ are actually subsumed.
  \item[RP] similarly, rewriting of positive clauses only  works for
    syntactical equality, not matching.
  \item[RN] is the same as RP but for rewriting negative clauses.
%}}}
\end{description}

\begin{figure}[htb]
%{{{
  \begin{center}

    % ER
    \AXC{$s \not\approx t |\Sigma$}
    \LL{ER}
    \RL{if $\sigma = \text{mgu}(s, t)$}
    \UIC{$\emptyset | \Sigma \circ \sigma $}
    \DP{} \\[12pt]

    % SN
    \AXC{$s \approx t | \Sigma$}
    \AXC{$u \not\approx v | \Sigma'$}
    \LL{SN}
    \BIC{$\sigma''(u[p \leftarrow t] \not\approx v) | (\Sigma \circ \sigma'') \uparrow (\Sigma' \circ \sigma'')$}
    \DP{}
    $\text{if} \left\{ \begin{array}{l}
        \sigma'' = \text{mgu}(u_{|p}, s) \\
        \sigma''(s) \not\preceq \sigma''(t) \\
        \sigma''(u) \not\preceq \sigma''(v) \\
        u_{|p} \not\in V \\
    \end{array}\right.$ \\[12pt]

    % SP
    \AXC{$s \approx t | \Sigma$}
    \AXC{$u \approx v | \Sigma'$}
    \LL{SP}
    \BIC{$\sigma''(u[p \leftarrow t] \approx v) | (\Sigma \circ \sigma'') \uparrow (\Sigma' \circ \sigma'')$}
    \DP{}
    $\text{if} \left\{ \begin{array}{l}
        \sigma'' = \text{mgu}(u_{|p}, s) \\
        \sigma''(s) \not\preceq \sigma''(t) \\
        \sigma''(u) \not\preceq \sigma''(v) \\
        u_{|p} \not\in V \\
    \end{array}\right.$ \\[12pt]

    \mbox{

    % TD1
    \AXC{$s \approx s | \Sigma $}
    \LL{TD1}
    \doubleLine{}
    \UIC{$\top$}
    \DP{}

    % TD2
    \AXC{$s \mathrel{R} t | \emptyset$}
    \LL{TD2}
    \RL{$ R \in \{ \approx, \not\approx \} $}
    \doubleLine{}
    \UIC{$\top$}
    \DP{}
  }
  \\[12pt]

    % PS
    %\AXC{$s \approx t |\sigma$}
    %\AXC{$u[p \leftarrow \sigma''(s)] \not\approx u[p \leftarrow \sigma''(t)] | \sigma' $}
    %\LL{PS}
    %\doubleLine{}
    %\BIC{$s \approx t | \sigma$ \qquad $\emptyset | \sigma \cup \sigma' \cup \sigma''$}
    %\DP{} \\[12pt]

    % NS
    %\AXC{$s \not\approx t | \sigma$}
    %\AXC{$\sigma''(s \approx t) | \sigma'$}
    %\LL{NS}
    %\doubleLine{}
    %\BIC{$s \not\approx t | \sigma$ \qquad $\emptyset | \sigma \cup \sigma' \cup \sigma''$}
    %\DP{} \\[12pt]

    % ME
    \AXC{$\rho(u) \approx \rho(v) | \Sigma$}
    \AXC{$u \approx v | \Sigma'$}
    \LL{ME}
    \RL{$\rho \text{ is a variable renaming}$}
    \doubleLine{}
    \BIC{$\rho(u) \approx \rho(v) | \Sigma \cup (\Sigma' \circ \rho)$}
    \DP{} \\[12pt]

    % ES
    \AXC{$s \approx t | \Sigma$}
    \AXC{$u[p \leftarrow s] \approx u[p \leftarrow t] | \Sigma' \cup \Sigma''$}
    \LL{ES}
    \RL{$
      \text{if} \left\{ \begin{array}{l}
          \Sigma'' \not= \emptyset \\
          \Sigma \leq \Sigma''
        \end{array}\right.  $}
    \doubleLine{}
    \BIC{$s\approx t | \Sigma \qquad u[p\leftarrow s] \approx u[p \leftarrow t] | \Sigma'$}
    \DP{} \\[12pt]

    % RP
    \AXC{$s \approx t | \Sigma$}
    \AXC{$u \approx v | \Sigma'$}
    \LL{RP}
    \doubleLine{}
    \BIC{$s \approx t | \Sigma$ \qquad $u[p \leftarrow t] \approx v | \Sigma'$}
    \DP{}
    $\text{if} \left\{\begin{array}{l}
      u_{|p} = s \\
      s \succ t \\
      \Sigma \leq \Sigma'\\
      u \not\succeq v ~ \text{or} ~ p \neq \lambda \\
    \end{array}\right.$ \\[12pt]

    % RN
    \AXC{$s \approx t | \emptyset$}
    \AXC{$u \not\approx v | \sigma$}
    \LL{RN}
    \doubleLine{}
    \BIC{$s \approx t | \emptyset$ \qquad $u[p \leftarrow t] \not\approx | \sigma$}
    \DP{}
    $\text{if} \left\{\begin{array}{l}
      u_{|p} = s \\
      s \succ t \\
      \Sigma \leq \Sigma'\\
    \end{array}\right.$

  \caption{The set of rules for unit rigid superposition}
  \label{fig:unit-sup-rules}
  \end{center}
%}}}
\end{figure}

%}}}

\subsection{Main Loop}
%{{{

Our objective with rigid E-unification is to attempt to close a branch
of the tableau prover (i.e., a set of boolean literals set to true).
To do so, all equational or atomic literals are added to a set of unit clauses
to process, with a label $\Sigma \triangleq \{ \emptyset \}$.
Then, the given-clause algorithm is applied to try and saturate the set.
Assuming a fair strategy, this will eventually find a solution
(i.e. derive $\clauseWithSubst{\emptyset }{\Sigma}$) if there exists one.
We refer the interested reader to~\cite{e_brainiac_prover} for more details.

Because the whole branch is treated by a single given-clause saturation loop,
we look for all solutions susceptible to close the branch at the same time.
Moreover, this technique is amenable to incrementality --- every time a
(dis)equation is decided by the SAT solver, we could add it to the saturation
set and perform a (limited) number of steps of the given-clause algorithm.

%}}}

\subsection{Example}
%{{{

To illustrate the calculus, we detail a refutation of the following set
of clauses stemming from group theory, where $f$ is the operator, $0$ the
(left-)neutral element and $m$ the (left-)inverse operator:
\[
  \begin{array}{rcl}
    \forall x~y~z.~ f(x,f(y,z)) &\approx& f(f(x,y),z) \\
    \forall x.~ f(0,x) &\approx& x \\
    \forall x.~ f(m(x),x) &\approx& 0 \\
    f(b,c) &\approx& 0 \\
    f(c,b) &\not\approx& 0 \\
  \end{array}
\]
Because the problem is purely equational, the tableau structure is trivial,
and all the work is done by the rigid superposition procedure;
however, the procedure needs two instances of some axioms to succeed.
The proof is shown in Figure~\ref{fig:unit-sup-proof-example}, but we
do not apply the merging rule to prevent substitution sets to grow too much
and clutter the proof.

\begin{figure}[htbp]
%{{{ example
\begin{center}
\begin{tabular}{clc}
  \toprule

  1 & axiom &
  $\forall x~y~z.~ f(x,f(y,z)) \approx f(f(x,y),z)$
  \\

  2 & axiom &
  $\forall x.~ f(0,x) \approx x$
  \\

  3 & axiom &
  $\forall x.~ f(m(x),x) \approx 0$
  \\

  4 & axiom &
  $f(b,c) \approx 0$
  \\

  5 & axiom &
  $f(c,b) \not\approx 0$
  \\

  6 & amplify(1) &
  $ f(X_1,f(Y_1,Z_1)) \approx f(f(X_1,Y_1),Z_1) $
  \\

  7 & amplify(1) &
  $ f(X_2,f(Y_2,Z_2)) \approx f(f(X_2,Y_2),Z_2) $
  \\

  8 & \renameVarsSymb(6) &
  $ \clauseWithSubst{ f(x,f(y,z)) \approx f(f(x,y),z) }{ \{ \mapVar{X_1}{x}, \mapVar{Y_1}{y}, \mapVar{Z_1 }{z} \} }$
  \\

  9 & \renameVarsSymb(7) &
  $ \clauseWithSubst{ f(x,f(y,z)) \approx f(f(x,y),z) }{ \{ \mapVar{X_2}{x}, \mapVar{Y_2}{y}, \mapVar{Z_2 }{z} \} }$
  \\

  10 & amplify(3) &
  $ f(m(X_3),X_3) \approx 0 $
  \\

  11 & amplify(3) &
  $ f(m(X_4),X_4) \approx 0 $
  \\

  12 & \renameVarsSymb(10) &
  $ \clauseWithSubst{ f(m(x),x) \approx 0 }{ \{ \mapVar{X_3}x \} } $
  \\

  13 & \renameVarsSymb(11) &
  $ \clauseWithSubst{ f(m(x),x) \approx 0 }{ \{ \mapVar{X_4}x \} } $
  \\

  14 & amplify(2) &
  $ f(0,X_5) \approx X_5 $
  \\

  15 & amplify(2) &
  $ f(0,X_6) \approx X_6 $
  \\

  16 & \renameVarsSymb(14) &
  $ \clauseWithSubst{ f(0,x) \approx x }{ \{ \mapVar{X_5}x \} }$
  \\

  17 & \renameVarsSymb(15) &
  $ \clauseWithSubst{ f(0,x) \approx x }{ \{ \mapVar{X_6}x \} }$
  \\

  \midrule

  18 & SP(4,8) &
  $ \clauseWithSubst{
      f(0,z) \approx f(b (f(c,z)))
    }{ \{ \mapVar{X_1}b, \mapVar{Y_1}c, \mapVar{Z_1}z \}
    }$
  \\

  19 & SP(15,18) &
  $ \clauseWithSubst{
      z \approx f(b,f(c,z))
    }{ \{ \mapVar{X_1}b, \mapVar{Y_1}c, \mapVar{Z_1}z, \mapVar{X_5}z \}
    }$
  \\

  20 & SP(9,12) &
  $ \clauseWithSubst{
      f(0,z) \approx f(m(x),f(x,z))
    }{ \{ \mapVar{X_2}{m(x)}, \mapVar{Y_2}{x}, \mapVar{Z_2}z, \mapVar{X_3}{x} \}
    }$
  \\

  21 & SP(16,20) &
  $ \clauseWithSubst{
      z \approx f(m(x),f(x,z))
    }{ \{ \mapVar{X_2}{m(x)}, \mapVar{Y_2}{x}, \mapVar{Z_2}z, \mapVar{X_3}{x}, \mapVar{X_6}{z} \}
    }$
  \\

  22 & SP(19,21) &
  $ \clauseWithSubst{
      f(c,z) \approx f(m(b),z)
    }{ \left\{
      \begin{array}{l}
        \mapVar{X_1}b, \mapVar{Y_1}c, \mapVar{Z_1}z, \mapVar{X_5}z,  \\
        \mapVar{X_2}{m(b)}, \mapVar{Y_2}{b}, \mapVar{Z_2}{f(c,z)},
           \mapVar{X_3}{b}, \mapVar{X_6}{f(c,z)}
      \end{array} \right\}
    }$
  \\

  23 & SP(13,22) &
  $ \clauseWithSubst{
      f(c,b) \approx 0
    }{ \left\{
      \begin{array}{l}
        \mapVar{X_1}b, \mapVar{Y_1}c, \mapVar{Z_1}b, \mapVar{X_5}b,  \\
        \mapVar{X_2}{m(b)}, \mapVar{Y_2}{b}, \mapVar{Z_2}{f(c,b)},
           \mapVar{X_3}{b}, \mapVar{X_6}{f(c,b)}
      \end{array} \right\}
    }$
  \\

  24 & SN(5,23) &
  $ \clauseWithSubst{
      0 \not\approx 0
    }{ \left\{
      \begin{array}{l}
        \mapVar{X_1}b, \mapVar{Y_1}c, \mapVar{Z_1}b, \mapVar{X_5}b,  \\
        \mapVar{X_2}{m(b)}, \mapVar{Y_2}{b}, \mapVar{Z_2}{f(c,b)},
           \mapVar{X_3}{b}, \mapVar{X_6}{f(c,b)}
      \end{array} \right\}
    }$
  \\

  25 & ER(24) &
  $ \clauseWithSubst{
      \emptyset
    }{ \left\{
      \begin{array}{l}
        \mapVar{X_1}b, \mapVar{Y_1}c, \mapVar{Z_1}b, \mapVar{X_5}b,  \\
        \mapVar{X_2}{m(b)}, \mapVar{Y_2}{b}, \mapVar{Z_2}{f(c,b)},
           \mapVar{X_3}{b}, \mapVar{X_6}{f(c,b)}
      \end{array} \right\}
    }$
  \\

  \bottomrule
\end{tabular}
\caption{Proof of a group theory problem}
\label{fig:unit-sup-proof-example}
\end{center}
%}}}
\end{figure}

%}}}
