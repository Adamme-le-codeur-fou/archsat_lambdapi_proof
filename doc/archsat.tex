
\section{ArchSat}

Plugins in archsat are the mechanism used to add support for theories.
Typically each plugins is in charge of taking care of a particular theory.
The main way for plugins to exchange information (so as to combine
the theories they describe) is through the assignments. Most plugin should
also rely on the watching mechanism implemented in the Dispatcher.

\subsection{General invariants}

In Archsat, much like in the Zenon automated theorem prover, terms and formulas
are immutable, i.e once created, they will not change during proof search.
This is especially important when considering the treatment of universally
quantified axioms (or existentially quantified goals), so keep in mind that
there is no substitution a posteriori.

Assignments are a map from terms to terms. As stated above, the
substitution that the assignments represent is supposed to be an involution,
which means that for any mapping $t \mapsto t'$, either $t'$ has no assignment,
or is assigned to itself. This is a particularly important
point because we use structural equality to decide equality between assigned
values, i.e if two terms are assigned to not structurally equal values, then
they are assumed to be distinct in the current model.
A consequence of that is that once a term has been assigned, its value will
not change (except for when the solver backtracks to before the assignment).

\subsection{Automatic backtracking}

Backtracking in ArchSat is done using a global undo stack, defined in the
Backtrack module. The main idea behind that is to avoid having explicit
functions to handle backtracking in the plugins. Instead, each plugin
can have its own internal state defined in its module, and is responsible for
logging changes onto the global stack. In order to be easier to use,
we define wrapped data structures, such as a hashtable. In this case, creation
of the hashtable requires an undo stack to use (typically the one provided by
the Dispatcher), but afterwards, all operations
on the hashtable automatically registers the corresponding undo actions in
the undo stack, allowing the extensions to not have to implement explicit
backtracking functions.

\subsection{Dispatcher}

The dispatcher is the module responsible for combining plugins in order
to have a single theory interface with the McSat Solver. The dispatcher
offers a powerful watch system for the plugins to use. It is used through
a function of the form:
\begin{lstlisting}
val watch: string -> int -> term list -> (unit -> unit) -> unit
\end{lstlisting}

Calling \lstinline{watch section k l f} register the callback \lstinline{f} to be called
as soon as there are strictly less than \lstinline{k} terms in \lstinline{l} that
are not assigned. Typically, watching with \lstinline{k=1} is used to evaluate and
propagate terms and formulas as soon as all arguments of an application are evaluated.
Watching with \lstinline{k=2} allows plugins to propagate constraints in their internal
state: for instance, if the formula $x < y$ is in the current set of assumptions,
and $y$ is assigned to $5$, it might be useful to add $x < 5$ to the internal set of
arithmetic constraints.

\subsection{Assignment strategy}

There are a few different strategies that can be considered for assigning terms.
A first approach is to allow the solver to decide on the assignment of any expression,
however this strategy forces theories to handle and propagate arbitrary constraints,
which can be complex. Imagine for instance deciding on the assignment of
$x + y$ and $2 * y - z$ before deciding on the value of $x$, $y$, and $z$.

While it is a perfectly valid strategy, we decide to use a more guided strategy,
where we do not to allow the solver to decide
on non-atomic values, and we use a bottom-up evaluation strategy for the terms
in the problems. This means that the solver can only decide on the values of constants
and variables, and that an expression is evaluated/assigned only once all subterms have
been evaluated.

\subsection{Logic in Archsat}

There are two different kind of logics used in Archsat.
\begin{itemize}
  \item First is the clausal
    logic used by the underlying McSat solver. In this logic, there is a set of
    clauses, which are themselves sets of formulas. The goal of the solver is
    to find an assignment such that every clauses contains at least one formula
    assigned to $\top$. The McSat solver is able to reason in this logic
    using boolean propagation, decisions and backtracking.
  \item Then there is the logic used in the input formulas, typically classical logic
    with boolean operators such as conjunction, disjunction or implication.
\end{itemize}

What is interesting is that clausal logic is intuitionistic. Indeed, the way a
SAT solver deduces $\bot$ from input clauses is that when backtracking, it deduces
from the conflict (which is either a hypothesis, or a tautology coming from the theory)
a backtrack clause that explains where the solver made a wrong decision.
While there are many suitable backtrack clauses that can be found from a conflict clause,
they can all be deduced from the assumptions by using resolution. Thus, whenver it finds
a problem is unsat, a SAT solver (and by extension, an McSat solver) is able to output a
resolution proof of the empty clause, which is a valid proof in intuitionistic logic.
The only source of non-intuitionistic reasoning in SAt/SMT solvers is the conversion
from the input formulas to a classically equivalent conjunctive normal form, and
possibly the tautologies that are given to the solver by the theory.

This will allow Archsat to handle intuitionistic problems in the future: since
the core of the solver does not need classical properties, there is only the need
for the theories used to be intuitionistic.

