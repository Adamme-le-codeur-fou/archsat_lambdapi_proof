# bset.zf

val tup : type -> type -> type.
val set : type -> type.
val mem : pi (a : type). a -> set a -> prop.
val pair : pi (a b : type).a -> b -> (tup a b).
val power : pi (a : type). set a -> set (set a).
val subset : pi (a : type). set a -> set a -> prop.
val times : pi (a b : type). set a -> set b -> set (tup a b).
val union : pi (a : type). set a -> set a -> set a.
val inter : pi (a : type). set a -> set a -> set a.

rewrite
  forall (a b : type) (z : tup a b) (S : set a) (T : set b).
    mem (tup a b) z (times a b S T) <=>
      (exists (x : a) (y : b). z = (pair a b x y) && mem a x S && mem b y T).

rewrite
  forall (a : type) (b : type) (x : a) (y : b) (S : set a) (T : set b).
    mem (tup a b) (pair a b x y) (times a b S T) <=> mem a x S && mem b y T.

#rewrite
#  forall a b z S.
#    mem (tup a b) z S <=> (exists x y. z = (pair a b x y) &&
#      mem (tup a b) (pair a b x y) S).

rewrite
  forall (a : type) (S T : set a).
    mem (set a) S (power a T) <=> (forall (x : a). (mem a x S) => (mem a x T)).

rewrite
  forall (a : type) (S T : set a). subset a S T <=> mem (set a) S (power a T).

rewrite
  forall (a : type) (S T : set a).
    S = T <=> (forall (x : a). (mem a x S) <=> (mem a x T)).

rewrite
  forall (a : type) (x : a) (S T : set a).
    mem a x (union a S T) <=> mem a x S || mem a x T.

rewrite
  forall (a : type) (x : a) (S T : set a).
    mem a x (inter a S T) <=> mem a x S && mem a x T.
